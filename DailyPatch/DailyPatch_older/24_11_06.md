field = 멤버변수 + 정적변수

이전에 이어서 생성자

실습: TelevisionTest

멤버변수와 지역변수는 이름이 같을 수 있다(둘을 구별함)
이름이 같은 변수를 부르면 더 좁은범위의 변수(지역변수)가 우선권을 가진다
이런 경우 멤버변수를 부르고 싶을때 클래스에서 this.를 붙여부른다

this: 객체 자신의 주소를 나타냄
메소드, 생성자에도 붙일 수 있지만 메소드는 이름+파라미터정보로 구별가능하므로 굳이 붙이지 않음
변수는 구별할 방법이 이름밖에 없으니 this.를 이용해 멤버변수와 지역변수를 구별한다

특수용법
this( ) : 자신의 생성자를 호출
생성자를 만들때 하는 일의 중복을 없애기 위해서 사용

생성자 내부에서만 가능
반드시 생성자의 첫번째 연산에 위치해야 함
<-- 메소드를 이용해서 대신할 수도 있음

생성자가 여러개 호출된다고 객체가 여러개 생성되는건 아니지만
적어도 하나의 객체는 생성된다

예제: UseSome UseHuman

// 보기-코드생략사용
// api documents

생성자 없이 멤버변수를 초기화할 수 있지만 대부분의 경우 의미있는 행위가 아님

접근제어자(access modifier) : 멤버변수, 메소드, 생성자, 클래스
- private
- 생략(default)
- protected
- public // 현재까지 배운 범위의 클래스에는 생략 or public만 가능

(아래로 갈수록 공공재가 됨)

private: 객체 자신만 접근 가능
생략(default): 동일한 패키지 정보를 가질 때 접근 가능
protected: '상속관계'일때 접근 가능
public: 제한이 없음

예제: UseFoo

기본패키지: 별도의 패키지 정보가 없을 때 같은 디렉토리에 들어있으면 패키지가 같은 것으로 취급

멤버변수: 특별한 이유가 없으면 private
	멤버변수는 고유한 값을 나타내고 변수는 값이 변할 수 있음
	객체의 정보에 대한 외부에서의 '직접접근'을 막음

메소드, 생성자: 특별한 이유가 없으면 public
	메소드, 생성자는 값이 아닌 일의 정의 <-- 외부에서 내용을 변경할 수 없음

클래스: 현재단계에서는 소스코드명이 될 클래스에 public
	아닌 클래스는 ( )

접근자와 설정자

예제: UseDummy

getter:
헤더규칙) public int getNum() { }
boolean) public boolean isOk() { }

setter:
헤더규칙) public void set(String str) { }
boolean) public void setOk(boolean ok) { }

왜 getter, setter를 쓸까?
getter, setter를 통해서 멤버변수를 읽고 쓰는 것과
public 멤버변수를 직접 읽고 쓰는 것은 완전히 다름 (허가 여부)

실습: UseMyClass
클래스를 만들때 기본으로 private, public, getter, setter, 생성자, toString을 만드는 습관을 들이기

정보 은닉: 사용자에게 드러나는 정보를 제한함
드러난 정보가 적을수록 사용이 편리하다

메소드: 멤버변수의 연산을 하려면 반드시 메소드를 통해야 함
멤버변수의 보호가 메소드의 가장 중요한 역할(멤버변수는 당연히 private상태)

실습: AccountTest

getter만 생성하고 setter를 생성하지 않으면 읽기만 가능한 멤버변수를 만들수도 있다

-----------------

절차지향과 객체지향
절차지향에서는 변수에 모든 함수가 접근 가능하기 때문에 문제가 발생했을 때 원인파악-해결이 어렵다
유지보수가 굉장히 힘들다
그렇게 문제가 점점 복잡해지고 많아지면서 절차지향에 비해 문제원인파악-해결이 훨씬 쉬운 객체지향으로 발전해왔다

다만 절차지향이 멸종한것은 아니고 단순하거나 작은규모의 프로그래밍에서는 여전히 유효하다

객체지향의 특징
	추상화
	캡슐화
	상속 // 아직 안배움
	다형성 // 아직 안배움

추상화: 객체가 가지고 있는 수많은 특징(정보)을 하나의 단어로 축약하는 것
	클래스헤더(추상적) : 클래스바디(구체적)
└ 정보를 표현하고 사용하기 간단해진다

캡슐화:	1. 객체의 정보를 보호한다
	2. 객체가 가진 많은 정보를 (사용하기 편하게) 하나로 만든다

// 인터페이스: 개발자와 사용자와의 접점

캡슐화의 장점:
정보의 보호 - 정보의 은닉 - 객체 간의 연관관계가 약해짐 - 유연성이 높아짐
다른 객체를 사용할 때 편리해짐

퀴즈: DiceGameTest : DiceGameFixTest

private 메소드의 존재 이유:
메소드를 분류해서 관리할 때 <-- 외부에서 메소드에 접근할 필요가 없음
일의 중복을 막기 위한 내부 연산에만 호출될 때