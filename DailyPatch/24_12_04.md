### MigLayout
- 자유롭게 크기조절이 가능한 GridLayout
```java
pnlCenter = new JPanel();
cardLayout = new CardLayout();
pnlCenter.setLayout(cardLayout);
JPanel pnlLogin = new JPanel();
pnlLogin.setLayout(new MigLayout("", "[100px][][][][100px]", "[40px][][][][40px]"));
// 5행 5열을 미그레이아웃으로 설정
JLabel lblId = new JLabel("아이디");
tfId = new JTextField(10);
JLabel lblPw = new JLabel("패스워드");
tfPw = new JPasswordField(10);
JButton btnLogin = new JButton("로그인");
JButton btnSignUp = new JButton("회원가입");
JLabel lblTry = new JLabel("");
pnlLogin.add(lblTry, "cell 1 0 3 1,growx");
pnlLogin.add(lblId, "cell 1 1,alignx left,aligny center");
pnlLogin.add(tfId, "cell 2 1,alignx left,aligny center");
pnlLogin.add(lblPw, "cell 1 2,alignx left,aligny center");
pnlLogin.add(tfPw, "cell 2 2,alignx left,aligny center");
pnlLogin.add(btnLogin, "cell 3 1 1 2,alignx left,growy");
pnlLogin.add(btnSignUp, "cell 1 3 3 1,growx,aligny top");
// 한 요소가 여러 그리드를 차지하는 것을 SPAN 이라고 한다
JPanel pnlSuccess = new JPanel();
JLabel lblMessage = new JLabel("환영합니다.");
lblMessage.setBorder(BorderFactory.createLineBorder(Color.RED, 1));
JButton btnLogout = new JButton("로그아웃");
pnlSuccess.setLayout(new MigLayout("align center center", "[][]", "[]"));
pnlSuccess.add(lblMessage, "cell 0 0,alignx center,aligny center");
pnlSuccess.add(btnLogout, "cell 1 0,alignx center,aligny center");
```
- 스윙은 동적요소 표현이 제한적이다

# Swing_etc
- MouseListener
```java
public class Main2 extends JFrame {
	public Main2() {
		JPanel pnl = new JPanel();
		pnl.setBackground(Color.WHITE);
		pnl.setLayout(null);
		pnl.setPreferredSize(new Dimension(500, 500));
		pnl.addMouseListener(new MouseListener() {
			
			@Override
			public void mouseReleased(MouseEvent e) {
				// 마우스를 눌렀을 때
				System.out.println(e.getX() + ", " + e.getY());
				// 창에서의 좌표를 전달
				System.out.println(e.getXOnScreen() + ", " + e.getYOnScreen());
				// 모니터상의 좌표를 전달
				
				System.out.println(e.getButton());
				// 눌린 버튼의 정보를 전달
				System.out.println(SwingUtilities.isLeftMouseButton(e));
				// 눌린 버튼이 왼쪽버튼이 맞는지 확인
			}
			
			@Override
			public void mousePressed(MouseEvent e) {
				// 마우스를 뗐을 때
			}
			
			@Override
			public void mouseExited(MouseEvent e) {
				// 마우스가 창에서 나갔을 때
			}
			
			@Override
			public void mouseEntered(MouseEvent e) {
				// 마우스가 창에 들어왔을 때
			}
			
			@Override
			public void mouseClicked(MouseEvent e) {
				// 마우스를 클릭했을 때
			}
		});
		
		add(pnl);
		
		setSize(500, 500);
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		setVisible(true);
	}
```
- MouseAdapter : 마우스리스너는 구현할 메소드가 너무 많기 때문에 원하는 메소드만 구현하기 위해서 사용하는 클래스
```java
pnl.addMouseListener(new MouseAdapter() {
	@Override
	public void mousePressed(MouseEvent e) {
		int x = e.getX();
		int y = e.getY();
		
		lblBox.setLocation(x, y);
	}
});
```
- Timer : 스윙에서 일정 시간마다 이벤트를 발생시키도록 하는 클래스
```java
private Timer timer;
// javax.swing.Timer;
public Main4() {
	JPanel pnl = new JPanel();
	pnl.setBackground(Color.WHITE);
	pnl.setLayout(null);
	pnl.setPreferredSize(new Dimension(500, 500));
	
	JLabel lblBox = new JLabel("");
	lblBox.setOpaque(true);
	lblBox.setBackground(Color.CYAN);
	lblBox.setSize(20, 20);
	pnl.add(lblBox);
	// 17ms 마다 이벤트를 발생시키는 타이머
	timer = new Timer(17, new ActionListener() {
		String direction = "down";
		int v = 2; // 한번에 2px씩 이동하게 설정
		
		@Override
		public void actionPerformed(ActionEvent e) {
			int x = lblBox.getX();
			int y = lblBox.getY();
			
			if (direction.equals("down")) {
				y += v;
				
				if (y == 450) {
					direction = "up";
					// y좌표가 450이 되면 위로 방향전환
				}
			} else if (direction.equals("up")) {
				y -= v;
				
				if (y == 0) {
					timer.stop();
					// 타이머 멈춤
					// y좌표가 0이 되면 이동을 멈춤
				}
			}
			lblBox.setLocation(x, y);
		}
	});
	pnl.addMouseListener(new MouseAdapter() {
		@Override
		public void mousePressed(MouseEvent e) {
			timer.start();
			// 마우스를 누르면 타이머가 시작
		}
	});
	
	add(pnl);
	
	setSize(500, 500);
	setDefaultCloseOperation(EXIT_ON_CLOSE);
	setVisible(true);
}
```
### RDBMS
- 통일된 같은 정보를 다루기 위한 시스템
- 서버 : 정보를 보관하고 있다
- 클라이언트 : 망을 통해 서버에 접속할 수 있다
- 서버가 열려 있는 컴퓨터의 위치를 알고 포트를 알고 계정정보도 알면 접속할 수 있다
- 클라이언트가 서버에 정보를 요청하면 서버는 정보를 클라이언트에게 전달한다 (call - return)
- 정보를 table(도표) 형태로 반환한다
# MySQL
- MySQL과 다른 DB시스템을 사용한다면 키워드가 다르거나 없을 수 있다
- SQL은 표준SQL을 공통으로 사용하나 방언SQL이 존재할 수 있다
- MariaDB는 MySQL을 상속해서 거의 비슷하게 사용할 수 있다
```SQL
-- SQL 한줄 주석
/*
	SQL (Structured Qurey Language)
    문장 종료 : ;
    문법을 지키지 않을 경우, 서버가 해석할 수 없어 결과 반환 셋을 전송해주지 못 함.
    대소문자를 구별하지 않음 - 코드를 대문자 또는 소문자로 통일해서 작성
*/
-- SELECT 명령어 : 서버에서 정보를 조회할 때
SELECT 10; -- 정수 리터럴 값 조회
SELECT 10 + 20; -- 정수 연산 결과 값 조회
SELECT @@VERSION; -- 서버 버전 조회

SELECT 200; -- 정수 리터럴 값 조회
SELECT 55.23; -- 실수

SELECT "문자열";
SELECT '문자열';

SELECT TRUE; -- SQL에서는 논리값을 숫자로 나타낸다
SELECT FALSE; -- 0은 거짓, 나머지 숫자는 참. 보통 1로 나타낸다

SELECT 10 + 20;
SELECT 20 - 30;
SELECT 55 * 33;
SELECT 11 / 3; -- 결과를 적당한 데이터형으로 변경한다
-- 부동소수점을 채용한다. 오차가 발생할 수 있음
SELECT 11 % 3;

SELECT 10 + "20";
SELECT "30" + "40"; -- SQL은 +연산은 숫자연산으로 간주하고 문자열을 숫자형으로 변환한다

SELECT "QWER" + "ASDF"; -- +연산자로 문자열 결합이 안된다

SELECT 200; -- 정수 리터럴 값 조회
SELECT 55.23; -- 실수

SELECT "문자열";
SELECT '문자열';

SELECT TRUE; -- SQL에서는 논리값을 숫자로 나타낸다
SELECT FALSE; -- 0은 거짓, 나머지 숫자는 참. 보통 1로 나타낸다

SELECT 10 + 20;
SELECT 20 - 30;
SELECT 55 * 33;
SELECT 11 / 3; -- 결과를 적당한 데이터형으로 변경한다
-- 부동소수점을 채용한다. 오차가 발생할 수 있음
SELECT 11 % 3;

SELECT 10 + "20";
SELECT "30" + "40"; -- SQL은 +연산은 숫자연산으로 간주하고 문자열을 숫자형으로 변환한다

SELECT "QWER" + "ASDF"; -- 따라서 +연산자로 문자열 결합을 할 수 없다

SELECT 10 = 10; -- sql에서는 논리연산자 모양이 다르다

SELECT 10 != 10;
SELECT 10 <> 10; -- 다른지 물어보는 표현이 두 가지 있다

SELECT 'qwer' = 'qwer';
SELECT '10' = 10; -- 사용편의를 위해 데이터타입을 엄격하게 따지지 않는다
SELECT 'asdf' = 'ASDF'; -- 대소문자 구분을 안한다

SELECT 'abc' < 'def'; -- 문자열 대소비교는 순서로 판단한다

SELECT TRUE && TRUE; -- and
SELECT TRUE || FALSE; -- or
SELECT !TRUE; -- not

SELECT TRUE AND TRUE;
SELECT TRUE OR FALSE;
SELECT NOT TRUE;

SELECT 10 AND 10;
SELECT '10' AND 10;
SELECT 'abc' AND 'def'; -- 문자는 false로 취급한다
```
