# MySQl
- **세션변수** : 서버에 접속하고 접속이 끊어질 때 까지 유지되는 변수
- **쿼리** (Query) : 조회 명령어
- **서브 쿼리** (Sub-Qurey) : 쿼리 내부의 작은 쿼리문
```sql
SET @myVar = 30; -- 세션변수 선언 문법
SET @yourVar := 'str'; -- 대입연산자의 모양이 java와 다르다
SET @yourVar := 100; -- 데이터타입을 가리지 않는다. 알아서 공간에 집어넣는다

SET @min := (SELECT MIN(salary) FROM employees); -- 조회 결과를 변수에 대입 가능
SELECT @min2 := MIN(salary) FROM employees; -- 조회 결과를 즉시 대입 가능

SELECT * FROM employees WHERE salary = @min; -- 세션변수 사용
--
SET @num = 0;
SELECT @num := @num + 1 AS '번호', first_name, last_name FROM employees;
-- 임의로 행 번호를 붙여서 결과를 조회할 수 있다
-- 초기화를 해주지 않으면 세션 변수는 누적된다

SELECT MIN(salary) FROM employees; -- 값 1개를 조회
SELECT * FROM employees
	WHERE salary = (SELECT MIN(salary) FROM employees); -- 값 1개를 조회하고 그 값을 이용해 조회
-- 쿼리 안에 들어간 쿼리를 서브쿼리라고 한다
SELECT * FROM employees WHERE salary >= (SELECT AVG(salary) FROM employees);

SELECT AVG(salary) FROM employees
	WHERE DEPARTMENT_ID = (SELECT * FROM departments WHERE DEPARTMENT_NAME = "IT");

SELECT * FROM employees
	WHERE JOB_ID IN (SELECT JOB_ID FROM employees
		WHERE CONCAT(first_name, last_name) IN ("PeterHall", "AlexisBull"));
-- 여러 값을 한번에 체크하고 싶다면 IN 키워드를 사용할 수 있다

-- 최소 임금 최대 임금 직원
SELECT * FROM employees 
	WHERE salary = (SELECT MIN(salary) FROM employees)
	OR salary = (SELECT MAX(salary) FROM employees);
-- 서브쿼리를 여러개 사용할 수 있다
-- 직원 별, 평균 임금과의 차이를 조회하기
SELECT first_name, last_name
	, ROUND(salary - (SELECT AVG(salary) FROM employees), 2) AS "격차"
    , ROUND(salary / (SELECT SUM(salary) FROM employees) * 100, 2) AS "비율"
	FROM employees;
-- 반올림을 할 수 있다
-- 서브쿼리를 조회에도 사용할 수 있다

-- 임금 하위 5명, 오름차순 정렬
SELECT * FROM employees ORDER BY salary LIMIT 5;
-- 위에 5명을 내림차순으로 정렬
SELECT * FROM (SELECT * FROM employees ORDER BY salary LIMIT 5) AS `result` ORDER BY salary DESC;
-- 조회 결과도 하나의 테이블이고 테이블에 별명을 붙여서 다시 조회할 수 있다

-- 부서명이 'IT'인 직원 중 임금 상위 3명을 오름차순으로 조회
SELECT * FROM
	(SELECT * FROM employees WHERE department_id = 
		(SELECT department_id FROM departments WHERE department_name = 'IT')
	ORDER BY salary DESC LIMIT 3) AS A
ORDER BY salary ASC;
-- 조회 결과에 붙이는 보통 별명은 앞글자 몇개를 따서 붙인다

CREATE VIEW it_emp AS
	SELECT * FROM employees WHERE department_id = 
		(SELECT department_id FROM departments WHERE department_name = 'IT');
-- view : 조회한 결과를 테이블로 저장할 수 있다

SELECT * FROM
	(SELECT * FROM it_emp ORDER BY salary DESC LIMIT 3) AS A
ORDER BY salary ASC;
-- 긴 쿼리를 보기 좋게 만들 수 있다
--
-- view는 읽기 전용이다 일반적으로 view를 이용해 데이터를 조작할 수 없다

-- 임금 상위3 하위3 조회
(SELECT * FROM employees ORDER BY salary ASC LIMIT 3)
	UNION
(SELECT * FROM employees ORDER BY salary DESC LIMIT 3);
-- UNION 키워드를 사용해 조회 결과를 합쳐서 볼 수 있다
-- UNION ALL 키워드를 사용해 중복된 조회 결과도 합칠 수 있다
-- 주의할 점 : 첫 조회의 양식과 이후 조회가 일치해야 UNION으로 결합할 수 있다
-- 양식과 별명이 첫 조회의 것을 따라가게 된다
```
---
### DATE, TIME
```sql
USE my_db;
/*
	지인들의 생일 정보
	이름	관계	생일
    길동	친구	2001.01.01
    둘리	친구	2005.02.02
    도너	동료	2002.03.03
	길동	사촌	2010.10.10
*/
CREATE TABLE IF NOT EXISTS births (
	regNo INT PRIMARY KEY AUTO_INCREMENT
	, name VARCHAR(20) NOT NULL
    , relation VARCHAR(10) NOT NULL
    , birth DATE -- RDBM에서 지원하는 날짜용 데이터타입
);

INSERT INTO births (name, relation, birth)
	VALUES ('길동', '친구', DATE '2001-01-01')
		, ('둘리', '친구', DATE '2005-02-02')
        , ('도너', '동료', DATE '2002-03-03')
        , ('길동', '사촌', DATE '2010-10-10');
-- 날짜형 데이터타입 사용법

INSERT INTO births (name, relation, birth)
	VALUES ('마이콜', '친구', '2012-12-12');
-- 문자열 형태로 입력해도 날짜로 인식하고 삽입한다
-- 날짜로 인식할 수 없는 경우 에러가 발생해 실수를 방지한다

SELECT EXTRACT(YEAR FROM birth) AS '생년' FROM births WHERE name = '둘리';
SELECT EXTRACT(MONTH FROM birth) AS '생월' FROM births WHERE name = '둘리';
SELECT EXTRACT(DAY FROM birth) AS '생일' FROM births WHERE name = '둘리';
-- EXTRACT 키워드를 사용해 날짜의 일부 정보만 보는 것이 가능하다
SELECT birth + INTERVAL 30 DAY AS '일자' FROM births WHERE name = '둘리';
-- INTERVAL 키워드를 사용해 날짜의 계산이 가능하다
SELECT DATE_ADD(birth, INTERVAL 30 DAY) FROM births WHERE name = "둘리";
SELECT ADDDATE(birth, 30) FROM births WHERE name = "둘리";
-- 날짜 관련 함수를 사용할 수 있다
-- 날짜를 빼는 계산은 DATE_SUB, SUBDATE

SELECT DATEDIFF(CURRENT_DATE(), birth) FROM births WHERE name = "둘리";
-- 현재 날짜를 확인할 수 있다
-- 두 날짜간의 일수차이를 확인할 수 있다

-- 요일을 확인할 수 있다 1. 일요일 2. 월요일 ...
SELECT DAYOFWEEK(birth) FROM births WHERE name = '둘리';

INSERT INTO births (name, relation, birth)
	VALUES ('톰', '친구', str_to_date('2001년 01월 01일', '%Y년 %m월 %d일'));
-- 문자열을 날짜형으로 바꿀수 있다

SELECT * FROM births;

-- 날짜 + 시간 : DATETIME, TIMESTAMP
SELECT CURRENT_TIMESTAMP(); -- ()는 생략할 수 있다

CREATE TABLE IF NOT EXISTS diary (
	title VARCHAR(20) NOT NULL DEFAULT 'untitle' -- null 미허용, 입력값이 없으면 untitle 삽입
    , content TEXT NOT NULL -- 텍스트 타입 : 문자열 타입, 한계가 매우 크다
    , logTime TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO diary (title, content, logTime)
	VALUES ('날짜와 시간을 배움', '타임스탬프로 표현이 가능함', TIMESTAMP '2024-12-06 12:36:00');
INSERT INTO diary (content) VALUES ('내용임');
-- 제목과 로그가 디폴트값으로 들어간다

ALTER TABLE diary
	ADD COLUMN updateAt TIMESTAMP
		DEFAULT CURRENT_TIMESTAMP
			ON UPDATE CURRENT_TIMESTAMP; -- 행의 변경 시간을 기록함
            -- ON UPDATE : 변경이 감지될때 기록

UPDATE diary SET content = '새로운 내용임' WHERE title = 'untitle';

SELECT * FROM diary;
```
