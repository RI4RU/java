
	코더 --> 개발자 --> 엔지니어
	클래스다이어그램에 getter, setter, 생성자에 대한 정보도 모두 들어가 있어야 한다
	클래스 만들때 일반적인 순서: 필드(멤버변수) -> 생성자 -> 메소드 - (getter, setter) or (getter, setter) - 메소드

실습: BankAccountTest, CarTest


	transaction: A-B-C-D 라는 과정이 진행될 때, 부분성공이 허용되지 않는 과정(전체성공 or 실패)
	rollback: transaction 중간에 실패가 발생할 경우 이전단계가 돌아가는게 아니라 진행을 초기화
	commit: transaction이 성공적으로 완료되어야 결과를 반영

상속: 클래스의 중복 멤버를 제거하기 위해 공통된 멤버를 부모클래스로 모음
or 이미 존재하는 클래스에 필요한 요소만 추가하여 자식클래스를 작성

상속의 특징(두 조건을 동시 만족해야 함)
	1. is - a 관계가 성립해야 함(하위개념은 상위개념의 요소를 모두 갖고있어야 함)
	2. 하위개념(자식)은 상위개념(부모)과 구분되는 +@ 가 있어야 한다
		멤버의 추가
		생성자의 변화
		etc.

*부모클래스-자식클래스 or 슈퍼클래스-서브클래스 라고도 함

일방향성: 상속 해준다(x) --> 상속 받는다(o)
	tree구조 = 최상위개념(root)(1개), 최하위개념(leaf) - 구성하는 각 개념(node)
	부모클래스가 변경될 때 자식클래스를 고려하지 않는다

	상속은 자식이 부모한테 매우 높은 의존성을 가진다
	- 아무것도 안했는데 문제가 발생할 수 있음
	- 사용에 신중을 기해야 함

실습: DogTest, CircleTest

클래스명 extends 부모클래스명 { } : 클래스는 부모클래스의 상속을 받는다

상속의 대상: 멤버(멤버변수 + 메소드)

간단하지만 강력하다
검증된 구조를 extends 키워드 하나로 모두 받아올 수 있다
대신 의존성이 높아 사용시 주의

Java 상속의 특징
	1. 다중 상속 불가(부모는 하나만)
		부모가 여럿이면: 개념의 충돌이 발생함
	2. 상속에 제한이 없다(자식은 많이)
	3. 상속 구조 맨 위에는 java.lang.Object 클래스가 있다 - 모든 클래스는 객체이다
		ex) toString()

상속과 접근 제어자
	private: 상속 x
	(default): 상속과 무관
	protected: 상속 o
	public: 상속 o
예제: A

상속과 생성자
예제: UseSubClass

자식은 부모의 멤버도 사용할 준비가 되어야 하기 때문에 부모객체가 먼저 생성되고 자식객체가 생성된다
자식은 부모객체의 주소를 알고 있음

super(); 부모클래스의 생성자를 호출함(파라미터는 필요에 따라 설정가능)
	부모클래스의 어떤 생성자를 부를지 파라미터를 통해서 지정가능
	자식클래스 생성자에 부모클래스 생성자 호출이 없다면 자동으로 super();가 생성자 첫 연산에 추가된다
		*super();는 생성자의 첫 연산이어야 하므로 this();와 같이 쓰려면 this();를 다른 메소드로 대체한다
super: 부모객체의 주소(바로 위의 부모만 찾을 수 있음)
예제: UseStudents
실습: EmployeeTest

메소드 오버라이딩 (=/= 메소드 오버로딩: 물리적으로 서로 다른 메소드를 만드는 것)
예제: UseSon

Override: 상속관계에서 자식클래스가 부모와 무엇을 하는지는 같지만, 어떻게 하는지가 달라질 때 사용하는 방법
	규칙:
	1. 메소드 이름, 파라미터 정보, 리턴 정보가 같아야 한다
	2. 접근제안자(변경은 가능하지만 더 좁아질 수는 없다)
메소드 오버라이드: 부모가 정의한 메소드와 물리적으로 동일한 메소드를 만든다

Override할 때, 조금만 달라져도 전혀 다른 메소드가 되고 그것을 발견하는 단계는 실행 단계이므로 수정은 더욱 늦어지게 된다
이 때, 컴파일 단계에서 미리 확인하는 방법이 어노테이션을 사용하는 것이다

@Override: 컴파일러에게 제대로 Override 되었는지 확인을 요청하는 키워드
@이름: annotation(어노테이션)
	-> 실행할 때도 영향을 줄 수 있다
	-> JDK 1.5~ 이후에 추가
	-> 컴파일 타임에 오버라이드가 제대로 되었는지 확인가능
오버라이드 이후에 부모의 메소드를 호출하고 싶으면 자식에게서 super.를 통해 호출해야 한다

*변수는 오버라이드 한다는 개념이 없다 - 변수이기 때문에 불러서 변경하면 된다
**메소드는 변하는 것이 아니기 때문에 재정의를 하는 오버라이드가 필요

*추상적인 개념을 통해 무엇을 하는지는 알지만 어떻게 해야할지 알 수 없는 상태가 아주 많다 - 추상클래스

*배열, 2차원배열 배우지 않았음
**상속을 배웠으나 다시 짚어주기를 요구