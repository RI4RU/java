개발자가 갖춰야 할 소양
	S/W 공학
	O/S

무엇을 클래스로 정의해야 하는가?
현실의 문제를 분석해서 해결에 있어서 중요한 부분

현실에서 자주 사용되는 객체는 클래스로 만들기 쉽다: 사전지식이 있기 때문
현실에서 자주 사용되지 않는 객체는 클래스로 만들기 어렵다: 사전지식이 없기 때문

UML(Unified Modeling Language)
클래스 다이어그램

가시성(visibility)
- (private)
~ ( )
# (protected)
+ (public)

실습: RocketTest PersonTest SongTest DogTest StudentTest MovieTest

객체의 생성과 소멸
생성: 객체가 메모리에 올라가 사용할 준비가 된 상태
소멸: heap상에서 더 이상 사용이 불가능한 객체를 garbage라고 하고 가비지 콜렉터가 삭제한 상태

System.gc(); // 가비지 콜렉터 요청
*콜렉터를 요청한다고 바로 쓰레기를 처리하는 것은 아님
언제 처리할지는 예측할 수 없음

인수 전달 방법

클래스에서 호출-연산할 때 데이터가 어떻게 변하는지 쉽게 알아보는 법
파라미터가 기본데이터형인 경우 메소드 내에서 어떤 연산을 해도 원래의 데이터에 직접 영향을 주지 못한다
오직 값을 리턴하고 사용자측에서 다시 받아야만 데이터를 변경할 수 있다
그러나 참조형으로 호출시에는 참조값을 이용하므로 객체의 데이터에 영향을 줄 수 있다

SomeEx

동적변수 vs 정적변수
메모리에 상주하는 시점이 기준(동적 정적의 기준은 접미어에 따라 조금씩 달라진다)
동적변수(할당): 메모리에 상주하는 시점을 변경할 수 있음
정적변수(할당): 메모리에 상주하는 시점을 변경할 수 없음

java에서 정적이란? static - 주체가 존재하지 않음(객체와 관계가 없음)
정적변수가 만들어진 계기 - c언어에서 '전역변수'를 java(객체지향)으로 설명할 수 없어서 만들어냄

static과 결합할 수 있는 것
정적 변수: 클래스 내의 변수와 결합할 수 있다
정적 메소드: 클래스 내의 메소드와 결합할 수 있다
정적 블록: 클래스 내부에 { }(실행 블록(실제로 사용하지는 않음)(객체가 메모리에 올라만가도 실행됨))이라는 것이 있고
이 실행블록과 결합할 수 있다
정적 클래스: 클래스 내부에 존재하는 클래스(inner-class)에는 접근 제어자를 모두 사용가능하고 static과 결합할 수 있다

정적 변수, 메소드는 객체의 구성요소가 아님 --> 공유됨

정적 변수, 메소드는 프로그램이 시작하기 전에 이미 메모리에 올라가 있다(클래스로더가 클래스를 읽어 들일 때)
그리고 그 메모리 상주 시점을 사용자가 임의로 변경할 수 없다

정적 변수는 아무 클래스에서든 접근할 수 있다

static이 붙은 메소드는 어느 클래스에 들어가 있어도 상관이 없다(객체와 관계가 없으므로)

public static void main(String[] args) { }
public: 프로그램을 시작 하는데 제한을 없어야한다
static: 프로그램을 시작 전에 main을 사용할 준비를 마쳐야한다
void: java프로그램은 종료시 가상머신과 함께 종료되므로 리턴이 없다
main: 메소드 이름(프로그램의 시작을 알리는 메소드)

정적변수를 참조변수를 통해서도 접근할 수 있고, 같은 클래스 내라면 클래스를 생략할 수도 있지만
해당 변수가 어떤 변수를 가르키는지 알아보기 어려우니 절대로 하지않는다
반드시, '클래스명.정적변수'로 호출할 것

static변수에 private를 붙여도 같은 객체 간에는 공유된다(타 클래스의 접근은 막음)

실습: PizzaTest

멤버변수에도 final을 붙여 값이 변하지 않도록 만들 수 있다(상수화)
한번 초기화되면 변경 불가능하기에 기본생성자에서 값을 초기화 하지 않음

class Foo {
	final static int OTHER = 1; // 모든 객체가 모두 같은 상수를 가져야 할때
	// 내가 임의로 정한 값(상수)에 따라 분기해야하는 경우 알아보기 쉬운 변수명으로 치환하고 싶을 때
	// 코드 가독성이 올라감

	final int NUM; // 객체가 상수를 가지지만 서로 다른 값을 가져야 할때

	public Foo(int num) {
		NUM = num;
	} // 모든 생성자에 상수 NUM에 대한 정의를 내려야 에러가 없다

} // 해당 용례로만 사용할 것

정적 메소드에서 정적 변수/메소드를 호출하면 에러가 없지만 
정적이지 않은 변수/메소드를 그냥 호출하면 에러가 발생함 - 호출을 위해서는 소유자를 알아야하기 때문

