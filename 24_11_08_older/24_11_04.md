369.java, 소수.java 문제 : boolean변수를 활용

객체 지향 프로그래밍

객체 지향 : Object + Oriented  (O.O)

object : 현실을 구성하는 모든 개념
oriented : ~에서 유래된 

객체 지향 방법론
현실에서 문제가 발생했을 때 문제를 구성하는 객체와 연관관계를 인지하고,
가상세계에서 문제를 구성하는 객체와 연관관계를 이용해서 문제를 해결하는 방식

O.O = O.O.A.D (Analysis Design) + O.O.P.L (Programming Language) 
내공(경험을 통해서만 성장) + 초식(미디어 등을 통해 이론적인 학습)

현실의 객체를 가상에서 구현하는 과정 : "객체 모델링"

객체지향과 절차지향의 차이
절차지향: 기계 중심

객체지향: 사람 중심

메세지: 객체 간의 상호작용

객체: state.상태(정보, 값) + behave.행위(기능) = 사람이 사물을 인식하는 방법

객체가 가지고 있는 개념을 상태와 행위로 분류한다 // 논리세계

가상세계에서 객체를 재구성 // 물리(컴퓨터)세계
물리세계에서의 객체.member = 멤버변수(=state) + 메소드(method)(=behave)

클래스	<--->	객체(instance)(object 중에서 메모리에 올라가 사용할 준비가 끝난 객체)
붕어빵틀			붕어빵

프로그래머에게는 인스턴스가 필요하다
-->인스턴스를 만드려면 클래스가 필요하다
-->인스턴스는 메모리상에 존재하므로 실체를 확인할 수 없다
-->클래스를 보고 인스턴스를 예상할 수 있다
-->클래스를 통해 같은 인스턴스를 여러번 생성할 수 있다(재사용성)
-->이렇게 생성된 인스턴스는 멤버변수와 메소드로 구성되어있다
-->클래스도 멤버변수와 메소드만으로 구성되었다고 볼 수 있다

실습: CircleTest

클래스: 사용자 정의 타입

. (dot): 참조연산자 (~안으로 들어간다)

객체 생성: 객체를 구성하는 멤버변수와 메소드를 사용할 준비
객체를 메모리에 올린다 == 멤버변수와 메소드를 메모리에 올린다

함수(function): '일의 집합'에 이름을 부여한 것
불규칙적인 연산의 중복이 발생했을 때, 중복을 소거할 수 있다

함수 --> 메소드
함수에는 없고 메소드에만 있는 특징: 주체(소유자)
누가 메소드를 쓰는지 구분함

ex) obj.getArea(); // obj(주체)의 getArea()를 실행

일을 수행만 하면되는 것
일을 수행할 때 필요한 정보를 줘야하는 것
일을 수행하고 결과를 반환하는 것
일을 수행하고 결과를 반환하지 않는 것

파라미터(parameter): 일을 수행할 때 필요한 정보(주체입장) <-- 인자(argument)(명령자입장)
--> 0~n개
리턴(return): 주체가 일을 수행하고 명령자에게 반환해야할 결과 
--> 0~1개

예제) MethodEx

메소드헤더에서 파라미터에는 이름이 있고 리턴값에는 이름이 없는 이유
--> 리턴값을 받을 쪽(사용자)이 이름을 붙이고 쓰면 됨

같은 클래스 안에서 메소드를 호출할 때는 주체가 자기자신이므로 메소드명만 쓴다

heap(힙): 객체가 존재하는 공간

참조형: 대답해야할 값이 여러 개일때, 값들이 있는 위치(주소)를 표시하는 것

기본데이터형 8개가 존재하는 이유: 조합해서 알아서 참조형 데이터를 만들어 사용하라고
참조 변수: 생성된 객체가 존재하는 메모리의 주소의 이름